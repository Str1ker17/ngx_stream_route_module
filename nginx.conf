#!./objs-module/nginx -c nginx.conf -e /dev/stderr

daemon off;
error_log /dev/stderr notice;
pid nginx.pid;
load_module objs-module/ngx_stream_route_module.so;

events {
}

http {

    client_body_temp_path nginx_run/client_body_temp;
    fastcgi_temp_path nginx_run/fastcgi_temp;
    proxy_temp_path nginx_run/proxy_temp;
    uwsgi_temp_path nginx_run/uwsgi_temp;
    scgi_temp_path nginx_run/scgi_temp;

    access_log /dev/stdout;
    server {
        listen 127.0.0.1:8008 http2;
        return 200 "HTTP backend\n";
    }
}

stream {
    stream_route_enable on;
    map $stream_route_type $stream_route_upstream {
        'proxy_connect' '192.168.75.1:3121';
        'proxy_plain'   '192.168.75.1:3121';
        'proxy_socks'   '192.168.75.1:1081';
        # 'http', 'proxy_tls' and 'unknown' goes there
        default         '127.0.0.1:8008';
    }
    # the logic is inverted here, since 192.168.75.1:3121 and 192.168.75.1:1081 are not configured for proxy_protocol
    # while 127.0.0.1:8008 is configured above
    map $stream_route_is_proxy $stream_route_upstream_proxy_protocol {
        '0' 'on';
        '1' 'off';
    }

    log_format stream '$time_local | #$connection $remote_addr:$remote_port -> [$server_addr:$server_port] -> $stream_route_upstream ($stream_route_type) $status CRX:$bytes_received CTX:$bytes_sent URX:$upstream_bytes_received UTX:$upstream_bytes_sent $session_time' 's ($upstream_connect_time + $upstream_session_time)';
    access_log /dev/stdout stream;

    server {
        # add "ssl" for frontend
        # add "proxy_protocol" for Xray fallback, also add "set_real_ip_from 127.0.0.1;" directive
        listen 127.0.0.1:8000;
        proxy_pass $stream_route_upstream;
        proxy_protocol off;
    }
}
